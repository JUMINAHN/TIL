# baekjoon_2217

사이트: 백준
난이도: 실버4
날짜: 2024년 11월 3일
다중 선택: 파이썬
문제: ??????, ※, △, 내것이 아님, 못푼문제, 문제이해, 부분정답, 아쉬움, 취약파트
알고리즘 유형: 탐욕(그리디)
완료: Yes
자료구조: 리스트
텍스트: 문제를 이해하지 못하고 패턴을 못찾는 것 같음

## 접근 방법 & 아이디어

## 알아두면 좋을 개념, TIP

## 코드 최종본

- 생각해보니까 굳이 count를 쓸필요가 없었음
- gpt를 통해서 문제를 이해하고, 방향성을 잡았던,, 문제

```python
# 문제의 키포인트는 모든 로프를 사용할 필요가 없는 것 !! == 이게 함정이다.
# 전체 값을 일단 내림차순 정렬하고
# 일단 중요한 것은 맨 마지막 값은 해당 되지 않음
# 따라서 현재의 값 *(count)를 해준다 => 내 앞에 있었던 친구는 이미 나의 값을 넘기 때문에 고려X
# 횟수 N을 모두 해주는게 아니라 나와 아까의 값을 곱해줘야 개수가 맞다
# 근데 최대를 구해야하기 떄문에 완전탐색으로 모든 경우를 구해야 한다.!!
N = int(input())
arr = [int(input()) for _ in range(N)] #N만큼 list를 만들고
arr.sort(reverse=True) #내림차순으로 정렬한다
#count_num
max_weight = 0 #최대 중량을 구해야 함
#count = 1 #횟수를 카운트한다 => 1부터 시작해야함
#가장 큰 값은 무시하고 패스해야할까?
for i in range(N) : #역순으로 접근
    # if i == 0: #역순 => 그 반례케이스
    #     continue
    # count += 1 #곱할 N같은 x를 구하기 위함
    sum = arr[i] * (i+1) #현재의 값  => 최대 중량의 값 => 굳이 count를 할필요가 없을듯?
    #print(max_weight, sum)
    if sum >= max_weight:
        max_weight = sum #max_weight는 바뀌게 되는 것
    #맨 첫번째
print(max_weight)
```

## 초기 코드 구현

### 트러블 슈팅1 : 값이 0이 되는 문제

---

- 문제를 구조화하고 이해하는데 시간이 조금 소요되었떤 문제

```python
#문제를 읽고 잘 와닿지 않았음
#뒤에서 부터 접근하려고 했으나 => 생각해보면 상관은 없을 것 같다 지금과 이전 값 비교?
#문제를 읽으면서 들었던 생각은 현재의 값이 그 다음의 x배를 넘는지를 판단하는 것이다

#즉 문제를 읽으면서 내린 판단은 => 총합보다 크지 않다는 것
#일단 list의 전체함 sum_list 를 구하고
#for구문으로 앞에서 부터 *N(로프의 개수)배만큼 한다
#그리고 그 로프의 개수가 sum_list 전체 합계를 넘는지 않넘는지 판단한다
#만약 전체합계를 넘는다면 성립될 수 없다.
#내부 자체에 sum을 둬야 계속해서 합계를 초기화하고 비교할 수 있다.
N = int(input())
arr = [int(input()) for i in range(N)] #값을 넣어준다
#확인print(arr)

#전체 합
sum_list = sum(arr) #전체의 합을 구한다
#target = arr[0] #해당 idx가 들어있는 값 
target = 0 #추후 N*특정 idx값이 들어갈 내용
#배열을 전체 순회한다.
for a in arr:
    sum = (a*4) #확인할 값
    if sum <= sum_list: #arr을 넘지 않는다면?
        #target이 된다.
        #target = a #target에 들어가는 값
        target = sum # 해당 곱한 값이 들어갈 것이니까
    else : 
        break #이제 더이상 볼 필요가 없으니 더 돌릴 필요가 없다
#결과값은 따라서 sum이랑 같다
print(target)
```

### 트러블 슈팅 2 : 틀렸다고 나옴..

---

- 문제를 이해하지 못해서 틀린 것일까?
    - 모르겠어서 질문 게시판의 반례들을 찾아서 돌려본다

```python
#문제를 읽고 잘 와닿지 않았음
#뒤에서 부터 접근하려고 했으나 => 생각해보면 상관은 없을 것 같다 지금과 이전 값 비교?
#문제를 읽으면서 들었던 생각은 현재의 값이 그 다음의 x배를 넘는지를 판단하는 것이다

#즉 문제를 읽으면서 내린 판단은 => 총합보다 크지 않다는 것
#일단 list의 전체함 sum_list 를 구하고
#for구문으로 앞에서 부터 *N(로프의 개수)배만큼 한다
#그리고 그 로프의 개수가 sum_list 전체 합계를 넘는지 않넘는지 판단한다
#만약 전체합계를 넘는다면 성립될 수 없다.
#내부 자체에 sum을 둬야 계속해서 합계를 초기화하고 비교할 수 있다.
N = int(input())
arr = [int(input()) for i in range(N)] #값을 넣어준다
#확인print(arr)

#전체 합
sum_list = sum(arr) #전체의 합을 구한다
#target = arr[0] #해당 idx가 들어있는 값 
target = 0 #추후 N*특정 idx값이 들어갈 내용

#생각해보니 정렬을 일단 먼저 진행해야 한다 -> 작은 것부터 확인하기 위해서
arr.sort()
#배열을 전체 순회한다.
for a in arr:
    sum = (a*N) #확인할 값 => a*4로 해놓아서 에러가 발생함 => 4는 곧 input N의 값
    #print(sum)
    if sum <= sum_list: #arr을 넘지 않는다면?
        #target이 된다.
        #target = a #target에 들어가는 값
        target = sum # 해당 곱한 값이 들어갈 것이니까
    else : 
        break #이제 더이상 볼 필요가 없으니 더 돌릴 필요가 없다
#결과값은 따라서 sum이랑 같다
print(target)
```

⇒ 반례

```python
3
5
6
10000
   
# Output
output : 15 #5 * 3
```

```python
#  모두 고르게 w/k 만큼의 중량이 걸리게 된다.

3
30 #-10
20
10 #+10 얻어서 낼 수 있다는 것인가?
 
output : 40 #20*2
#모두 다 더한 값 .. 60 이게 아니다? 
#그런데 그럼 3이랑 뭐가 있다는 것 ? 
```

⇒ ??? 모르겠다

### 트러블 슈팅 3 : 지피티 참고를 보고 생각하면서 다시 풀어봄

---

```python
# 문제의 키포인트는 모든 로프를 사용할 필요가 없는 것 !! == 이게 함정이다.
# 전체 값을 일단 내림차순 정렬하고
# 일단 중요한 것은 맨 마지막 값은 해당 되지 않음
# 따라서 현재의 값 *(count)를 해준다 => 내 앞에 있었던 친구는 이미 나의 값을 넘기 때문에 고려X
# 횟수 N을 모두 해주는게 아니라 나와 아까의 값을 곱해줘야 개수가 맞다
# 근데 최대를 구해야하기 떄문에 완전탐색으로 모든 경우를 구해야 한다.!!
N = int(input())
arr = [int(input()) for _ in range(N)] #N만큼 list를 만들고
arr.sort(reverse=True) #내림차순으로 정렬한다
#count_num
max_weight = 0 #최대 중량을 구해야 함
count = 0 #횟수를 카운트한다
for a in arr :
    sum = a * (count+1) #현재의 값  => 최대 중량의 값
    if sum >= max_weight:
        max_weight = sum #max_weight는 바뀌게 되는 것
    count += 1 #곱할 N같은 x를 구하기 위함
    #맨 첫번째
print(max_weight)
```

```python
3
5
6
10000 #해당 케이스의 반례가 발생한다..
# Output
~~output : 15 #5 * 3 -> 여기 낚임~~ 
output : 10000
```

→ 질문 게시판 반례를 봤는데 이게 아니다

### 트러블 슈팅 4 : 25%에서 멈춤

---

```python
# 문제의 키포인트는 모든 로프를 사용할 필요가 없는 것 !! == 이게 함정이다.
# 전체 값을 일단 내림차순 정렬하고
# 일단 중요한 것은 맨 마지막 값은 해당 되지 않음
# 따라서 현재의 값 *(count)를 해준다 => 내 앞에 있었던 친구는 이미 나의 값을 넘기 때문에 고려X
# 횟수 N을 모두 해주는게 아니라 나와 아까의 값을 곱해줘야 개수가 맞다
# 근데 최대를 구해야하기 떄문에 완전탐색으로 모든 경우를 구해야 한다.!!
N = int(input())
arr = [int(input()) for _ in range(N)] #N만큼 list를 만들고
arr.sort(reverse=True) #내림차순으로 정렬한다
#count_num
max_weight = 0 #최대 중량을 구해야 함
count = 1 #횟수를 카운트한다 => 1부터 시작해야함
#가장 큰 값은 무시하고 패스해야할까?
for i in range(N) : #역순으로 접근
    if i == 0: #역순
        continue
    count += 1 #곱할 N같은 x를 구하기 위함
    sum = arr[i] * count #현재의 값  => 최대 중량의 값
    #print(max_weight, sum)
    if sum >= max_weight:
        max_weight = sum #max_weight는 바뀌게 되는 것
    #맨 첫번째
print(max_weight)
```

⇒ 루프에 대한 인덱스 산정의 오류 

## 지피티 참고

문제를 이해하는 데 어려움을 겪고 계신 것 같습니다. 제가 문제의 핵심 포인트와 여러분의 접근 방식에 대해 설명해 드리겠습니다.

[문제 이해]

1. 여러 개의 로프가 있고, 각 로프는 서로 다른 중량을 들 수 있습니다.
2. 로프를 병렬로 연결하면 중량을 나눌 수 있습니다.
3. k개의 로프를 사용할 때, 각 로프에는 w/k의 중량이 걸립니다.
4. 목표는 들어올릴 수 있는 물체의 최대 중량을 찾는 것입니다.
5. **모든 로프를 사용할 필요는 없습니다.**

## 접근 방식의 문제점

1. 전체 합을 구하는 것은 불필요합니다. 문제는 각 로프의 개별 능력과 관련이 있습니다.
2. 정렬은 좋은 아이디어입니다. 하지만 오름차순이 아닌 내림차순으로 정렬해야 합니다.
3. 로프의 개수와 각 로프의 능력을 곱하는 아이디어는 좋습니다. 하지만 모든 로프를 사용할 필요는 없다는 점을 고려해야 합니다.

## 가이드라인

1. 로프를 내림차순으로 정렬하세요.
2. 가장 강한 로프부터 시작하여, 각 단계에서 다음을 계산하세요:
    - 현재까지의 로프 수 * 현재 로프의 능력
3. 각 단계에서 계산된 값 중 최대값을 찾으세요.

이 방식을 사용하면, 강한 로프를 우선적으로 사용하면서 동시에 더 많은 로프를 사용할 때의 이점도 고려할 수 있습니다.

예를 들어, [10, 15, 20] 이라는 로프가 있다면:

1. 20 * 1 = 20
2. 15 * 2 = 30
3. 10 * 3 = 30

이 경우 최대값은 30이 됩니다.

이 가이드라인을 바탕으로 다시 한번 코드를 작성해 보시기 바랍니다. 여전히 어려움이 있다면 추가적인 질문을 해주세요.

## 다른 방법 접근 시도